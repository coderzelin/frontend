### HTTP

#### HTTP 方法

- HTTP1.0: GET,POST,HEAD
- HTTP2.0: OPTIONS,PUT,DELETE,TRACE,CONNECT

#### 这些方法的作用

- GET：获取服务器的资源
- POST：发送数据给服务器
- HEAD：获取 GET 请求返回的头部信息
- OPTIONS：获取服务器所支持的通信选项
- PUT：用于新增资源或者更新资源
- DELETE：删除资源
- PATCH：用于对资源的部分更改
- TRACE：追踪路径
- CONNECT：要求用隧道协议连接代理

#### GET 和 POST 区别

- 数据传输方式不同：GET 请求是通过 URL 传递数据，POST 请求时通过请求体传输数据
- 安全性不同：POST 请求的数据是放在请求体的，比较安全，而 GET 请求是放在 URL 上的，通过历史记录和缓存可以查到数据
- 数据传输大小不同：因为 GET 请求时通过 URL 传输数据，而浏览器对 URL 长度有限制，POST 请求传输的数据大小没有限制
- GET 请求是无害的，刷新，后退等操作对 GET 请求无害，而 POST 请求会重复提交表单
- 特性不同：GET 是安全（这里的安全是指只读特性，就是使用这个方法不会引起服务器状态变化）且幂等（幂等的概念是指同一个请求方法执行多次和仅执行一次的效果完全相同），而 POST 是非安全非幂等

#### POST 和 PUT 都是给服务器发送新增资源，有什么区别

PUT 和 POST 方法的区别是，PUT 方法是幂等的(即发送多次请求和发送一次请求的结果是相同的，无副作用)，而 POST 方法是非幂等的

还有一个区别是 PUT 方法的 URI 指向具体的单一资源，而 POST 方法指向的是资源的集合

#### HTTP 的请求报文

请求报文由 4 部分组成

- 请求行
- 请求头
- 空行
- 请求体

#### HTTP 的响应报文

响应报文由 4 部分组成

- 响应行
- 响应头
- 空行
- 响应体

#### HTTP 常见的状态码

2xx: 请求成功

- 200：表示客户端发送的请求被服务器正确处理
- 204：表示请求成功，但响应的主体不包括内容

3xx: 重定向

- 301：永久重定向，表示资源被分配给新的 URL
- 302：临时重定向，表示资源临时被分配给新的 URL
- 304：表示命中协商缓存

4xx：客户端错误

- 400：请求报文存在语法错误
- 401：未授权
- 403：服务器禁止访问
- 404：资源未找到
- 408：请求超时

5xx：服务端错误

- 500：服务器在执行请求的时候发生了错误
- 501：请求超出服务器的能力范围，例如服务器不支持当前请求的某个功能，或者不支持当前的方法
- 503：表示服务器暂时不可访问，无法处理请求
- 505：服务器不支持，或者拒绝支持客户端请求的 HTTP 版本

#### HTTP 的 keep-alive 是干什么的

在早期的 HTTP/1.0 版本中，每次发送请求前都要进行 TCP 连接，当响应后就会断开连接，下一次发送请求又要重新进行 TCP 连接，而创建连接的过程需要消耗时间和资源，为了减少资源消耗，缩短响应时间，就需要重用连接，在后来的 HTTP/1.0 和 HTTP/1.1 中，引入了重用连接的机制，就需要在请求头上加上 Connect:keep-alive 来告诉对方这个请求响应后的 TCP 链接不要断开，下一次发起请求的时候还用这个 TCP 链接

keep-alive 的优点

- 较少的 CPU 和内存使用（由于同时打开的链接减少了）
- 允许请求和应答的 HTTP 管线化
- 降低拥塞机制（TCP 链接减少了）
- 减少了后续请求的延迟（无需再进行握手）
- 报告错误无需关闭 TCP 链接

#### HTTPS 是什么

HTTPS 是安全版的 HTTP，因为 HTTP 协议的数据都是明文传播的，所以对一些敏感信息的传输很不安全，HTTPS 是由 HTTP 和 SSL 协议/TLS 协议构建的可加密传输，进行身份认证的一种网络协议，即在应用层和传输层之间使用 SSL 加密数据

#### HTTP 和 HTTPS 的区别

- HTTP 是超文本传输协议，它是明文传输的，不安全的，HTTPS 是 HTTP 协议+SSL 协议/TLS 协议的一种网络协议，它是可以进行加密传输和身份认证的
- HTTP 需要 ca 证书，费用较高
- HTTP 和 HTTPS 的连接方式不一样，HTTP 用的是 80 端口，HTTPS 用的是 443 端口

#### 浏览器在使用 HTTPS 传输数据的流程

1. 首先客户端通过 URL 访问服务器建立 SSL 连接。
2. 服务端收到客户端请求后，会将网站支持的证书信息（证书中包含公钥）传送一份给客户端。
3. 客户端的服务器开始协商 SSL 连接的安全等级，也就是信息加密的等级。
4. 客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。
5. 服务器利用自己的私钥解密出会话密钥。
6. 服务器利用会话密钥加密与客户端之间的通信

#### HTTP2.0 相比 HTTP1.0 有什么优点

##### 二进制分帧

HTTP2.0 采用二进制分帧进行数据传输，而不是 HTTP1.x 的文本格式传输数据，二进制协议解析更加高效

##### 头部压缩

可以理解为只发送差异数据，而不是全部发送，从而减少头部的信息量

##### 服务器推送

服务端可以在发送页面 HTML 时主动推送其它资源，而不用等到浏览器解析到相应位置，发起请求再响应。例如服务端可以主动把 JS 和 CSS 文件推送给客户端，而不需要客户端解析 HTML 时再发送这些请求

##### 多路复用

HTTP 1.x 中，如果想并发多个请求，必须使用多个 TCP 链接，且浏览器为了控制资源，还会对单个域名有 6-8 个的 TCP 链接请求限制

HTTP2.0中
- 同域名下所有通信都在单个连接上完成。
- 单个连接可以承载任意数量的双向数据流。
- 数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装

#### HTTP 缓存

##### 强缓存（不会发送请求到服务器）
- Expires：返回的是服务端的时间，而且是 HTTP1.0的，而现在浏览器都是用的 HTTP1.0，还有就是过期时间是服务端返回的时间，客户端的时间和服务端的时间如果存在误差，就会造成命中缓存的误差
- cache-control（优先级高）：常见的取值有private、public、no-cache、max-age，no-store，默认为private
  - private：客户端可以缓存
  - public：客户端和代理服务器都可以缓存
  - max-age=xxx：缓存的内容将在xxx秒后失效
  - no-cache：需要使用协商缓存来对比数据
  - no-store：所有内容都不使用缓存，包括强缓存和协商缓存

##### 协商缓存（会发送请求到服务器）
- Last-Modified/If-Modified-Since：
  - Last-Modified：服务器在响应请求的时候告诉浏览器资源最后修改的时间
  - If-Modified-Since：再次请求时，通过这个字段告诉服务器上次服务器返回的资源最后修改时间，服务器再通过这个字段的时间和服务器资源最后修改时间作比较，如果大于这个时间则返回，说明资源未修改，响应 HTTP 状态码304，告诉浏览器继续使用所保存的 cache，如果小于这个时间，说明资源已更改，响应整个资源并返回状态码 200

- Etag/If-None-Match(优先级高)：
  - Etag：服务器在响应资源的时候，会告诉浏览器这个资源在服务器的一个唯一标识符
  - If-None-Match：浏览器再次请求资源的时候会带上服务器上次返回的唯一标识符，与服务器当前资源的标识符作比较，如果不同则返回200状态码，响应资源，如果相同的话就返回304状态码，告诉浏览器继续使用保存的cache
